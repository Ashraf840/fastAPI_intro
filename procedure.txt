############### Ref ###############
Youtube Video Link:   https://www.youtube.com/watch?v=7t2alSnE2-I
###################################



#####   Procedure of building a system with FastAPI #####


1. Create the "main.py" file. Inside that, import the fastapi module & build simple APIs using simple python-methods.

2. After building the method & decorating with the instance of FastAPI ("app"), we need to start the server, we use the following cmd.
    uvicorn main:app --reload

    Syntax:  uvicorn fileName:FastAPI_objectName --reload

NB:  Uvicorn is a lightning-fast ASGI server, which can be used to run django-projects. 
    The operation that is wrapped with a FastAPI decorator, is called "Path Operation Function".


-----------------> Break down of FastAPI

2. Initialize empty git repository in the working directory.
    Also create the ".gitignore" file.

3. For dynamic routing in the path of FastAPI decorator, we use second-bracket "{}" along with the pathName string leading a forward-slash.
    Then we can use that as a variable in the 


-----------------> [ Path Parameter ]  Pass id/ other data dynamically inside the FastAPI routing-path
    To use that in the path-operation-functions.

4. Firstly use the second bracket in the path-string. To use this path-string-variable inside the path-operation-function,
    we need to use param in the method. By default, it will use the dynamic value as string inside the methods.

5. To define the value as string/ integer/ boolean/ float, it's required to define inside the method's parameter.


-----------------> FastAPI using Swagger UI for Frontend UI

6. To view the developed APIs in the browser, use "docs" keyword after the base-url ( "http://127.0.0.1:8080/docs/" )


-----------------> Alternative of Swagger UI for Frontend UI

7. Use "redoc" after the base-url ( "http://127.0.0.1:8080/docs/" )


-----------------> [ Query Parameter ] Pass Query Parameter in the routing-string.

[ NB ]:  Query parameters are not going to change the routing path of the FastAPI path. We can accept the query parameter 
    from the routing-path-string using paramterized function.

( Pass 'limit' query paramter)
8. Use the browser to use query in the routing-path by using the "?limit=10", then it can be fetched inside the function using
    the paraterized function. ( Please view the "blogList" function )


-----------------> [ Path Parameter ] Pass Default Path Parameter, thus it'll not throw errors for the not passing required paramters.

9. Inidividually specify default values for all the parameters of a method. Thus it'll not throw an error & asked for the values of the parameters.

10. If any optional paramters is passed in the method, then we are required to define that using the keyword "Optional" following the colon. 
    Then assign that parameter with "None".


-----------------> How does FastAPI know if the parameter is a query-param or a path-param?

[ Note ]:  FastAPI is smart enough to understand that if a variable is accepted in the method-param, and it matches any dynamic variable of the path-string,
    then it'll operate as path-parameter, otherwise, it'll treat other parameters as query-parameters.
    ANd it'll throw an error, if any defult value is not defined for the params as well as not metioned in the url while hitting the API.


-----------------> API: Create a new blog 

11. For creating a new blog inside the DB, we first need to establish the connection with the database.

12. [ Establish DB Connection ]: inside the "database.py"
        Create the db-engine using the SQLAlchemy. Here we need to define the db path in the directory. Initially, we are using the SQLite DB.
        Then need to instansiate the db-table mapping using the "declarative_base" module.
        Create the DB session using the sessionmaker.
    
[ NB ]:  The model-class inside the "schemas.py" is responsible for creating the request-body in the browser/ client/ user-end.
        The model-class inside the "models.py" is responsible for mapping the db-table as well as table-fields in the DB.

13. [ "main.py" ]  For making the migrations inside the DB, we need to define the engine using the following code-block.
            models.Base.metadata.create_all( engine )
    Create the function ( "create_blog" ) to create the row inside the DB.

[ IMPORTANT ]:  Any API function interacting with the DB should have the "db" param whose type will be define as Session inported from the "sqlalchemy.orm".
[ NB ]:  When we create an API, it's very important to provide an appropriate status-code.

14. We can define the status code inside the api-path-decorator with an extra parameter.
    Follow the link below to define the appropriate http-status-codes.
        https://docs.python.org/3/library/http.html#http.HTTPStatus
    [ or follow ]:  https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
    
    [ Alternatively - better approach ]: Import the "Status" module from the "fastapi" & 
        use that in the "status_code" param. The VS Code auto-complete will help to guide.

15. To ensure appropriate status-code while handling exception, we are required to use the "Response" module imported from "fastapi".
    The response param in the method will be as "Response".
    The status_code param will be overriden.


-----------------> Blog Delete API

16. To delete any record from the DB, we use the "delete" mwthod along with the "fastapi" decorator ( "app" ).
    Firstly, need to make a query into the DB using the "filter" method. The blog 'id' will be passed from the api-path through the method-param.
    In SQLAlchemy, the delete method works with the "filter" method. ( *tried to use the 'delete()' method along with the 'get()' ).
    Finally, the db-session-instance is required to be committed to make an effect in the DB.

    [ NB ]: If the status-code "204" is provided as param along with the api-path-url, then the "delete" API won't return any response-body.

    [ Further Development - Done ]:  Establish the exception-handling of no such available record for deleting.


-----------------> Blog Update API

Ref [ Aid to build the data-update API ]:  https://www.youtube.com/watch?v=2g1ZjA6zHRo
    [ Time Frame ]:  01:08:30

17. To update a particular record from the DB, first fetch that record from the DB. Thus, the "id" will be passed using the api-url-path through the method-param.
    Then the request data ("title", "body"), will be assigned to the instance of the record.
    Finally, make the "commit()" func to actually take the effect in the db-table.

    [ Optional ]: Can return the updated data from the db-table, for that, make a "refresh()" func before that.


-----------------> Response Model ( aka response-schema )
    
18. As the name suggest, For the response rom the API to the client, 
    we are required to define response-models.
    By using a response-model, we can customize the response-body sent from the API to the client/ browser.
    Create another schema-class which will be used for displaying the response-body after hitting the API from the client.
    The schema-class will be used in the API-url-path as another param.
    [ NOTE ] Since the response will be a provided from the API, so the response-model should be inside the faspAPI decorator's param instead of the method's param.
    
    Use the response-model in the "get_individual_blog_detail" & "get_all_blogs" APIs.

    The response model param defines the response exactly similar to the response-model aka pydantic-model/ schema we have defined inside the "schemas.py" class.

    [ IMPORTANT ]:  If we want to apply response-model to such API where multiple-records exist inside the response-body, 
    then we need to wrap that with the "List[]" class imported from the "typing" module.

    [ Better Approach ]: Instead of extending the main-schema-model as the response-model, extends/ inherits the request-model.
    Means, the respone-model & the request-body-model should be separated, without extending the model created for the request-body.
    Then, the response-model will be able to work properly.


-----------------> Create User API

19. Create a schema for providing a request-body for the client/ browser.
    After that we required the DB connection in the mthod thorugh the method-param.
    Then, the actual db-model aka SQLAlchemy model is required to be created.

[ NOTE ]: THe password is not hashed in the response-body.

Make the password hashed in the response-body after the API in called.
20. Install two pip modules:  passlib[bcrypt] & bcrypt
    Import the  CrpytContext frm the "passlib.context" module.
    Make the instance of the password-hashing.
    Hash the requested-password before setting that inside the user-creation-instance.

    [ NB ]:  For hashing, we can create a class in a separate file called "hashing.py".
    Inside that file, create a method ("bcrypt_hash") inside a class called "Hash".
    This class-method will be used while creating the new user-instance & provide the "request.password" in the method param.


-----------------> Build a response model for the user

21. Build a response-nmodel for the user in order to display the name & email of the user.
    This response-model will be created in the "schemas.py" file & passed through the API param.


-----------------> Show the routes/endpoints using the tags

22. For seprating the endpoints inside the documentation, that time, we can use the tags.
    It'll seprate the endpoints according to the topics.
    i.e. to seprate the blogs & users, we use the tags "blogs" & "tags".
    Use the as the api-url-path params.


-----------------> Relationships between the models

23. When we want to make relationship between two tables, then we use the "relationship" from the "sqlalchemy.orm" inside the "models.py" file.
    
    [ NOTE ]:  We are require to define the "back_populates" param. 
    
    But while using the param "back_populates", we need to define the models according to their tableNames.

    Syntax:
        relFieldName = relationship( "modelName", back_populates='otherRelModelFieldName' )

    [ NOTE ]:  This "relFieldName" should be generated between both the models. 
    
    But to define relationship between two models, we need the foreignKey column in both models.
    Syntax:
        FK_columnName = Column( dataType, ForeignKey( 'otherModelTableName.id' ) )
    [ NB ]:  dataType is typically be the "Integer" type.

    [ NB ]:  If we don't pass the user-id while creating a new blog, then it'll throw an error.
    So we're hard-coding the user-id while creating the blog-record, we're defining the user-id=1


-----------------> Modify the response model after establishing the relationship between two SQLAlchemy models

24. To view the creator of a specific blog while called through API, then we create another field inside the "" schema (serializer)/ pydantic model.
    the fieldName should be exactly similar to the fieldName defined inside the SQLAlchemy mode inside the "models.py" file.
    Syntax:
        schemaFieldName: otherUserModelName
    [ NB ]:  schemaFieldName = SQLAlchemy_model_relField
        But the "schemaModel", which is going to be called in another schemaModel should be above that schemaModel.

25. But then if we want to get all the blogs while a specific user or all user is called, then we should use the main "blog" schema.
    [ NB ]:  If the response is consisted of multiple records, then it should be wrapped up with the "List[]" class.
        Also, the response class models will also contain the class "Config()" to enable the "orm_mode".


-----------------> APIRouter

Doc Topic Ref:  https://fastapi.tiangolo.com/tutorial/bigger-applications/

26. Since the application is getting bigger, we need to refactor to manage the code base of our application. 
    So, we need to create a folder called "router", all the routers will be inside that directory. Create an empty "__init__.py" file there.
    Create two route-files called "user.py" & "blog.py" file. Inside these route-files, import the "APIRouter" from the "fastapi" module.
    Just like instantiating the "fastAPI" inside the "main.py" file, the APIROuter will also be instantiated.

        [ NB ]:  Initially move the "get all blogs" API to the "user.py" file from the "main.py" file.

27. The func for getting the db-sesison is moved to the "database.py" file.
    [ NB ]:  Import all the necessary files into the "routers.py" file.

28. In order to enbale the path-operations' APIs, we need to register the routes on our "main.py" file.
    [ NB ]: Just like impoting all the urls from the other apps' urls in the django-environment's main "urls.py" file using the "include" keyword.

    Import all the route files from the "routers" directory.
    Include the route-files inside the "include_router()" func of fastapi-instance/object in the "main.py" file.


-----------------> Initialize tags while initializing APIRouter

29. After refatoring the APIs, we can define the tags in the params while initializing the APIRouter.
    Thus the tags from each API path-params.
    Example:
            router = APIRouter(
                tags=["User"]
            )


-----------------> Using prefix in all the routes

30. All the API routes can have a prefix. It can be done inside the APIRouter initialization param.
    By doing this, we can refactor & cleanse the api-path string while defining the APIs.


-----------------> Refactor the Routers

[ NB ]:  Put all the path-operations in the separated files inside the "repository" directory.
    Main codes of the path-operations will be moved there & in the path-operations, the repo-file methods will be called.
    By this approach, we can make the code more organized & clean.

31. What is the responsibility of routers? => To route the paths of every path-operations/ methods.
    So, all the functional codes that were used in the path-operations should be moved to a dedicated place called the 
    "repository" directory. There will be files for the path operations of every topic seperately.
    Then those functions will be called inside the path operations.
    [ NOTE ]:  This functions are required to be distinctive than the path-operations (method) names.


-----------------> User Login & Verify Password

Doc Ref:  https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/
Doc Topic:  OAuth2 with Password (and hashing), Bearer with JWT tokens

# Create the route so that the user can login using the email & password

32. Create another router file for the authentication called "authentication.py".
    Then create another schema/serializer/pydantic model for the user login to handle the request of user posing from the browser.

[ NOTE ]:  The oauth2 module for handling the authentication in fastapi required username for authentication.
    Thus the pydantic-model for handling the login-request-body has the username instead of email.
    Then fetch the user-record from the SQLAlchemy model by providing the user-email & the password inside the request-body of the browser.
    Lately, we need to initialize the JWT token.
    Before implementing the JWT, we need to verify the password. For that, we will create another method called "verify()" inside the model-class "Hash".
    In the "verify()" method, two params will be passed to receive the "hashed_password" & "plain_password".
    hashed_password = will be get from the model user.
    plain_password = will be get from the requerst body.
    The actual "verify( plain_pass, hashed_pass )" method will be used from the "CryptContext" class of the "passlib.context".


-----------------> Generate JWT Token

Install Library:  pip install python-jose

33. It's requried to have the SECRET_KEY, ALGORITHM & ACCESS_TOKEN_EXPIRY_MINUTES to encode the generated JWT Access Token.
    Create a separate file ( "jwt_token.py" ) to generate JWT token & put all the variables there.
    [ NB ]:  Don't create a file called "token.py", instead create a file called "jwt_token".

34. Then create two response/schema model accordingly for displaying token & another model for the username (email).

35. Inside the 'jwt_token.py' file, we'll create a method called ("create_access_token"), this method will have two params to receive a data-dict (token-included) & for token-expiration-time.
    "create_access_token" method breakdown:
        # get the data-dict ( typically user-email )
        # check if the expiry-time is provided, otherwise, the expiry-time will be created using the "timedelta" method.
        # append the expiry-time with the data-dictionary
        # generate the "jwt_token" using the "jwt.encode()" method imported from the "python-jose".


-----------------> Protect the routes behind the token-authentication ( ROutes behind the 'Authentication' )
                    OAuth2 Validation

# [ IMPORTANT ]:  Now we need to use the "OAuth2PasswordBearer". This will hit the login-url-api using the "tokenURL".
        In my case, the login-api is defined as "/auth/loginAPI/" inside the "blog\oauth2.py" file.
        Moreover, if we want to fetch the token from the login-api-route, in that case, we are required to use the "OAuth2PasswordRequestForm" without any dependancy, 
        instead of "schemas.Login" model in the path-operations-param. Thus, it'll change the request-body of that api-route.


[ Install requirements ]
#       pip install python-multipart
This is because OAuth2 uses "form data" for sending the username and password.



# [ NB ]:  Whenever we want to give authentication to any route, we need to specify that this route is going to depend upon a function called "get_current_active_user".
    "get_current_active_user" is nothing but checking if the user is active or not by having a dependency method called "get_current_user". 
    [ NB ]: We can directly use the "get_current_user" method to validate the token by decoding using the "jwt" package from the "python-jose" module.
    The dependecy method ( "get_current_user" ) has a parameter to receive the auth-token, which will depend upon the "oauth2_scheme" variable. 
    This "oauth2_scheme" variable is instantiated by using the "OAuth2PasswordBearer()". Inside the "OAuth2PasswordBearer()", we just need to mention that from which route it'll fetch the token.
    This method "get_current_user" will check the validity of the token.

    [ IMPORTANT ]:  Inside this method, we are required to specify the login-api-route through the "tokenURL".
            In my case, the login-api-url is "/auth/loginAPI/".
            This route can also be metioned as "auth/loginAPI".


36. Create a new file called "oAuth2.py". Inside this file, firstly, create the method "get_current_user".
    Inside this method, firstly create a template-variable for the credential-exceptions so that we can raise exception by just calling the variable.
    Then we will decode the token using the jwt package. The code-block for decoding the jwt-token is placed inside the "jwtToken.py" file,
    created the method as "verify_token" method.


37. Create another method ( "verify_token" ) inside the "jwt_token.py" file. This method will be called inside the "get_current_user" method of "oauth2.py" file. 
    This "verify_token" method will use the "decode()" method from the "jwt" module. In the "decode()" method, we need the token, SECRET_KEY & the algorithm.
    After decoding, assign that data inside the "payload" variable, & from that variable, get the "user-email" by calling the key called "sub".
    After extracting the user-email from the "payload" variable, pass that in the schema-model called "TokenData" through another variable called "email".
    
    [ IMPORTANT ]  The "verify_token" gets completed by passing the decoded "user-email" to the schema-model "TokenData".

38. [ IMPORTANT ]  To make the autorization successful, we need to use the "OAuth2PasswordRequestForm" inside the login-api's path-operations param,
    which is inside the "blog\routers\authentication.py" file as a request-body instead of schem-model called "login".



